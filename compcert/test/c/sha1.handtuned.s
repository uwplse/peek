# File generated by CompCert 2.4
# Command line: -fno-peeps -stdlib ../../runtime -dc -dclight -dasm -S -o sha1.handtuned.s sha1.c
	.section	.rodata
	.align	1
__stringlit_2:
	.ascii	"passed\000"
	.type	__stringlit_2, @object
	.size	__stringlit_2, . - __stringlit_2
	.section	.rodata
	.align	1
__stringlit_4:
	.ascii	"Cannot determine endianness\012\000"
	.type	__stringlit_4, @object
	.size	__stringlit_4, . - __stringlit_4
	.section	.rodata
	.align	1
__stringlit_3:
	.ascii	"Test `%s': %s\012\000"
	.type	__stringlit_3, @object
	.size	__stringlit_3, . - __stringlit_3
	.section	.rodata
	.align	1
__stringlit_1:
	.ascii	"FAILED\000"
	.type	__stringlit_1, @object
	.size	__stringlit_1, . - __stringlit_1
	.local	arch_big_endian
	.comm	arch_big_endian, 4, 4
	.text
	.align	16
SHA1_copy_and_swap:
	.cfi_startproc
	subl	$36, %esp
	.cfi_adjust_cfa_offset	36
	leal	40(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ebx, 16(%esp)
	movl	%esi, 20(%esp)
	movl	%edi, 24(%esp)
	movl	%ebp, 28(%esp)
	movl	0(%edx), %esi
	movl	4(%edx), %ebx
	movl	8(%edx), %edi
	movl	arch_big_endian, %ecx
	testl	%ecx, %ecx
	jne	.L100
.L101:
	testl	%edi, %edi
	jle	.L102
	movzbl	0(%esi), %edx
	movzbl	1(%esi), %ebp
	movzbl	3(%esi), %eax
	movb	%al, 0(%ebx)
	movzbl	2(%esi), %ecx
	movb	%cl, 1(%ebx)
	movl	%ebp, %eax
	movb	%al, 2(%ebx)
	movb	%dl, 3(%ebx)
	leal	4(%esi), %esi
	leal	4(%ebx), %ebx
	leal	-1(%edi), %edi
	jmp	.L101
.L100:
	leal	0(,%edi,4), %ecx
	movl	%ebx, 0(%esp)
	movl	%esi, 4(%esp)
	movl	%ecx, 8(%esp)
	call	memcpy
.L102:
	movl	16(%esp), %ebx
	movl	20(%esp), %esi
	movl	24(%esp), %edi
	movl	28(%esp), %ebp
	addl	$36, %esp
	ret
	.cfi_endproc
	.type	SHA1_copy_and_swap, @function
	.size	SHA1_copy_and_swap, . - SHA1_copy_and_swap
	.text
	.align	16
SHA1_transform:
	.cfi_startproc
	subl	$372, %esp
	.cfi_adjust_cfa_offset	372
	leal	376(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ebx, 16(%esp)
	movl	%esi, 20(%esp)
	movl	%edi, 24(%esp)
	movl	%ebp, 28(%esp)
	movl	0(%edx), %ebx
	leal	32(%ebx), %esi
	leal	48(%esp), %ecx
	movl	$16, %edx
	movl	%esi, 0(%esp)
	movl	%ecx, 4(%esp)
	movl	%edx, 8(%esp)
	call	SHA1_copy_and_swap
	movl	$16, %eax
.L103:
	leal	48(%esp), %ecx
	movl	-12(%ecx,%eax,4), %ecx
	leal	48(%esp), %edx
	movl	-32(%edx,%eax,4), %edx
	xorl	%edx, %ecx
	leal	48(%esp), %edx
	movl	-56(%edx,%eax,4), %edx
	xorl	%edx, %ecx
	leal	48(%esp), %edx
	movl	-64(%edx,%eax,4), %edx
	xorl	%edx, %ecx
	leal	48(%esp), %esi
	leal	0(,%ecx,2), %edx
	shrl	$31, %ecx
	orl	%ecx, %edx
	movl	%edx, 0(%esi,%eax,4)
	leal	1(%eax), %eax
	cmpl	$80, %eax
	jl	.L103
	movl	0(%ebx), %eax
	movl	%eax, 40(%esp)
	movl	4(%ebx), %esi
	movl	8(%ebx), %edx
	movl	12(%ebx), %ebp
	movl	16(%ebx), %eax
	movl	%eax, 32(%esp)
	xorl	%edi, %edi
.L104:
	movl	%edx, %eax
	xorl	%ebp, %eax
	movl	%esi, %ecx
	andl	%eax, %ecx
	movl	%ebp, %eax
	xorl	%ecx, %eax
	movl	40(%esp), %ecx
	rorl	$27, %ecx
	leal	1518500249(%eax,%ecx,1), %ecx
	movl	32(%esp), %eax
	leal	0(%ecx,%eax,1), %eax
	leal	48(%esp), %ecx
	movl	0(%ecx,%edi,4), %ecx
	leal	0(%eax,%ecx,1), %ecx
	movl	%ebp, 32(%esp)
	movl	%edx, %ebp
	movl	%esi, %edx
	rorl	$2, %edx
	movl	40(%esp), %esi
	movl	%ecx, 40(%esp)
	leal	1(%edi), %edi
	cmpl	$20, %edi
	jl	.L104
.L105:
	cmpl	$40, %edi
	jge	.L106
	movl	%esi, %ecx
	xorl	%edx, %ecx
	xorl	%ebp, %ecx
	movl	40(%esp), %eax
	rorl	$27, %eax
	leal	1859775393(%ecx,%eax,1), %ecx
	movl	32(%esp), %eax
	leal	0(%ecx,%eax,1), %ecx
	leal	48(%esp), %eax
	movl	0(%eax,%edi,4), %eax
	leal	0(%ecx,%eax,1), %eax
	movl	%ebp, 32(%esp)
	movl	%edx, %ebp
	movl	%esi, %edx
	rorl	$2, %edx
	movl	40(%esp), %esi
	movl	%eax, 40(%esp)
	leal	1(%edi), %edi
	jmp	.L105
.L106:
	cmpl	$60, %edi
	jge	.L107
	movl	%esi, %eax
	andl	%edx, %eax
	movl	%eax, 36(%esp)
	movl	%esi, %eax
	orl	%edx, %eax
	movl	%eax, %ecx
	movl	%ebp, %ecx
	andl	%eax, %ecx
	movl	%ecx, %eax
	movl	36(%esp), %eax
	orl	%ecx, %eax
	movl	40(%esp), %ecx
	rorl	$27, %ecx
	leal	-1894007588(%eax,%ecx,1), %eax
	movl	32(%esp), %ecx
	leal	0(%eax,%ecx,1), %eax
	leal	48(%esp), %ecx
	movl	0(%ecx,%edi,4), %ecx
	leal	0(%eax,%ecx,1), %eax
	movl	%ebp, 32(%esp)
	movl	%edx, %ebp
	movl	%esi, %edx
	rorl	$2, %edx
	movl	40(%esp), %esi
	movl	%eax, 40(%esp)
	leal	1(%edi), %edi
	jmp	.L106
.L107:
	cmpl	$80, %edi
	jge	.L108
	movl	%esi, %ecx
	xorl	%edx, %ecx
	xorl	%ebp, %ecx
	movl	40(%esp), %eax
	rorl	$27, %eax
	leal	-899497514(%ecx,%eax,1), %eax
	movl	32(%esp), %ecx
	leal	0(%eax,%ecx,1), %ecx
	leal	48(%esp), %eax
	movl	0(%eax,%edi,4), %eax
	leal	0(%ecx,%eax,1), %ecx
	movl	%ebp, 32(%esp)
	movl	%edx, %ebp
	movl	%esi, %edx
	rorl	$2, %edx
	movl	40(%esp), %esi
	movl	%ecx, 40(%esp)
	leal	1(%edi), %edi
	jmp	.L107
.L108:
	movl	0(%ebx), %ecx
	movl	40(%esp), %eax
	leal	0(%ecx,%eax,1), %eax
	movl	%eax, 0(%ebx)
	movl	4(%ebx), %ecx
	leal	0(%ecx,%esi,1), %ecx
	movl	%ecx, 4(%ebx)
	movl	8(%ebx), %eax
	leal	0(%eax,%edx,1), %ecx
	movl	%ecx, 8(%ebx)
	movl	12(%ebx), %eax
	leal	0(%eax,%ebp,1), %edx
	movl	%edx, 12(%ebx)
	movl	16(%ebx), %eax
	movl	32(%esp), %edx
	leal	0(%eax,%edx,1), %ecx
	movl	%ecx, 16(%ebx)
	movl	16(%esp), %ebx
	movl	20(%esp), %esi
	movl	24(%esp), %edi
	movl	28(%esp), %ebp
	addl	$372, %esp
	ret
	.cfi_endproc
	.type	SHA1_transform, @function
	.size	SHA1_transform, . - SHA1_transform
	.text
	.align	16
	.globl SHA1_init
SHA1_init:
	.cfi_startproc
	subl	$12, %esp
	.cfi_adjust_cfa_offset	12
	leal	16(%esp), %edx
	movl	%edx, 0(%esp)
	movl	%ebx, 4(%esp)
	movl	0(%edx), %ebx
	movl	$1732584193, %ecx
	movl	%ecx, 0(%ebx)
	movl	$-271733879, %eax
	movl	%eax, 4(%ebx)
	movl	$-1732584194, %edx
	movl	%edx, 8(%ebx)
	movl	$271733878, %ecx
	movl	%ecx, 12(%ebx)
	movl	$-1009589776, %eax
	movl	%eax, 16(%ebx)
	xorl	%eax, %eax
	movl	%eax, 28(%ebx)
	xorl	%ecx, %ecx
	movl	%ecx, 20(%ebx)
	xorl	%edx, %edx
	movl	%edx, 24(%ebx)
	movl	4(%esp), %ebx
	addl	$12, %esp
	ret
	.cfi_endproc
	.type	SHA1_init, @function
	.size	SHA1_init, . - SHA1_init
	.text
	.align	16
	.globl SHA1_add_data
SHA1_add_data:
	.cfi_startproc
	subl	$36, %esp
	.cfi_adjust_cfa_offset	36
	leal	40(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ebx, 16(%esp)
	movl	%esi, 20(%esp)
	movl	%edi, 24(%esp)
	movl	%ebp, 28(%esp)
	movl	0(%edx), %esi
	movl	4(%edx), %edi
	movl	8(%edx), %ebx
	movl	24(%esi), %edx
	leal	0(%edx,%ebx,8), %ecx
	movl	%ecx, 24(%esi)
	cmpl	%edx, %ecx
	jae	.L109
	movl	20(%esi), %edx
	leal	1(%edx), %eax
	movl	%eax, 20(%esi)
.L109:
	movl	20(%esi), %eax
	movl	%ebx, %ecx
	shrl	$29, %ecx
	leal	0(%eax,%ecx,1), %ecx
	movl	%ecx, 20(%esi)
	movl	28(%esi), %eax
	testl	%eax, %eax
	je	.L110
	movl	$64, %ebp
	subl	%eax, %ebp
	cmpl	%ebp, %ebx
	jae	.L111
	leal	32(%esi,%eax,1), %eax
	movl	%eax, 0(%esp)
	movl	%edi, 4(%esp)
	movl	%ebx, 8(%esp)
	call	memcpy
	movl	28(%esi), %ecx
	leal	0(%ecx,%ebx,1), %eax
	movl	%eax, 28(%esi)
	jmp	.L112
.L111:
	leal	32(%esi,%eax,1), %edx
	movl	%edx, 0(%esp)
	movl	%edi, 4(%esp)
	movl	%ebp, 8(%esp)
	call	memcpy
	movl	%esi, 0(%esp)
	call	SHA1_transform
	leal	0(%edi,%ebp,1), %edi
	subl	%ebp, %ebx
.L110:
	cmpl	$64, %ebx
	jb	.L113
	leal	32(%esi), %ecx
	movl	$64, %eax
	movl	%ecx, 0(%esp)
	movl	%edi, 4(%esp)
	movl	%eax, 8(%esp)
	call	memcpy
	movl	%esi, 0(%esp)
	call	SHA1_transform
	leal	64(%edi), %edi
	leal	-64(%ebx), %ebx
	jmp	.L110
.L113:
	leal	32(%esi), %edx
	movl	%edx, 0(%esp)
	movl	%edi, 4(%esp)
	movl	%ebx, 8(%esp)
	call	memcpy
	movl	%ebx, 28(%esi)
.L112:
	movl	16(%esp), %ebx
	movl	20(%esp), %esi
	movl	24(%esp), %edi
	movl	28(%esp), %ebp
	addl	$36, %esp
	ret
	.cfi_endproc
	.type	SHA1_add_data, @function
	.size	SHA1_add_data, . - SHA1_add_data
	.text
	.align	16
	.globl SHA1_finish
SHA1_finish:
	.cfi_startproc
	subl	$36, %esp
	.cfi_adjust_cfa_offset	36
	leal	40(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ebx, 16(%esp)
	movl	%esi, 20(%esp)
	movl	%edi, 24(%esp)
	movl	0(%edx), %ebx
	movl	4(%edx), %esi
	movl	28(%ebx), %eax
	leal	1(%eax), %edx
	movl	$128, %ecx
	movb	%cl, 32(%ebx,%eax,1)
	cmpl	$56, %edx
	jle	.L114
	leal	32(%ebx,%edx,1), %edi
	xorl	%ecx, %ecx
	movl	$64, %eax
	subl	%edx, %eax
	movl	%edi, 0(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, 8(%esp)
	call	memset
	movl	%ebx, 0(%esp)
	call	SHA1_transform
	xorl	%edx, %edx
.L114:
	leal	32(%ebx,%edx,1), %edi
	xorl	%ecx, %ecx
	movl	$56, %eax
	subl	%edx, %eax
	movl	%edi, 0(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, 8(%esp)
	call	memset
	leal	20(%ebx), %ecx
	leal	88(%ebx), %eax
	movl	$2, %edi
	movl	%ecx, 0(%esp)
	movl	%eax, 4(%esp)
	movl	%edi, 8(%esp)
	call	SHA1_copy_and_swap
	movl	%ebx, 0(%esp)
	call	SHA1_transform
	movl	$5, %ecx
	movl	%ebx, 0(%esp)
	movl	%esi, 4(%esp)
	movl	%ecx, 8(%esp)
	call	SHA1_copy_and_swap
	movl	16(%esp), %ebx
	movl	20(%esp), %esi
	movl	24(%esp), %edi
	addl	$36, %esp
	ret
	.cfi_endproc
	.type	SHA1_finish, @function
	.size	SHA1_finish, . - SHA1_finish
	.text
	.align	16
do_test:
	.cfi_startproc
	subl	$148, %esp
	.cfi_adjust_cfa_offset	148
	leal	152(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ebx, 16(%esp)
	movl	%esi, 20(%esp)
	movl	0(%edx), %ebx
	movl	4(%edx), %esi
	leal	48(%esp), %eax
	movl	%eax, 0(%esp)
	call	SHA1_init
	movl	%ebx, 0(%esp)
	call	strlen
	leal	48(%esp), %ecx
	movl	%ecx, 0(%esp)
	movl	%ebx, 4(%esp)
	movl	%eax, 8(%esp)
	call	SHA1_add_data
	leal	48(%esp), %edx
	leal	24(%esp), %ecx
	movl	%edx, 0(%esp)
	movl	%ecx, 4(%esp)
	call	SHA1_finish
	leal	24(%esp), %ecx
	movl	$20, %eax
	movl	%ecx, 0(%esp)
	movl	%esi, 4(%esp)
	movl	%eax, 8(%esp)
	call	memcmp
	testl	%eax, %eax
	je	.L115
	leal	__stringlit_1, %edx
	jmp	.L116
.L115:
	leal	__stringlit_2, %edx
.L116:
	leal	__stringlit_3, %eax
	movl	%eax, 0(%esp)
	movl	%ebx, 4(%esp)
	movl	%edx, 8(%esp)
	call	printf
	movl	16(%esp), %ebx
	movl	20(%esp), %esi
	addl	$148, %esp
	ret
	.cfi_endproc
	.type	do_test, @function
	.size	do_test, . - do_test
	.data
	.align	1
	.global	test_input_1
test_input_1:
	.byte	97
	.byte	98
	.byte	99
	.byte	0
	.type	test_input_1, @object
	.size	test_input_1, . - test_input_1
	.data
	.align	1
	.global	test_output_1
test_output_1:
	.byte	169
	.byte	153
	.byte	62
	.byte	54
	.byte	71
	.byte	6
	.byte	129
	.byte	106
	.byte	186
	.byte	62
	.byte	37
	.byte	113
	.byte	120
	.byte	80
	.byte	194
	.byte	108
	.byte	156
	.byte	208
	.byte	216
	.byte	157
	.type	test_output_1, @object
	.size	test_output_1, . - test_output_1
	.data
	.align	1
	.global	test_input_2
test_input_2:
	.byte	97
	.byte	98
	.byte	99
	.byte	100
	.byte	98
	.byte	99
	.byte	100
	.byte	101
	.byte	99
	.byte	100
	.byte	101
	.byte	102
	.byte	100
	.byte	101
	.byte	102
	.byte	103
	.byte	101
	.byte	102
	.byte	103
	.byte	104
	.byte	102
	.byte	103
	.byte	104
	.byte	105
	.byte	103
	.byte	104
	.byte	105
	.byte	106
	.byte	104
	.byte	105
	.byte	106
	.byte	107
	.byte	105
	.byte	106
	.byte	107
	.byte	108
	.byte	106
	.byte	107
	.byte	108
	.byte	109
	.byte	107
	.byte	108
	.byte	109
	.byte	110
	.byte	108
	.byte	109
	.byte	110
	.byte	111
	.byte	109
	.byte	110
	.byte	111
	.byte	112
	.byte	110
	.byte	111
	.byte	112
	.byte	113
	.byte	0
	.type	test_input_2, @object
	.size	test_input_2, . - test_input_2
	.data
	.align	1
	.global	test_output_2
test_output_2:
	.byte	132
	.byte	152
	.byte	62
	.byte	68
	.byte	28
	.byte	59
	.byte	210
	.byte	110
	.byte	186
	.byte	174
	.byte	74
	.byte	161
	.byte	249
	.byte	81
	.byte	41
	.byte	229
	.byte	229
	.byte	70
	.byte	112
	.byte	241
	.type	test_output_2, @object
	.size	test_output_2, . - test_output_2
	.text
	.align	16
do_bench:
	.cfi_startproc
	subl	$212, %esp
	.cfi_adjust_cfa_offset	212
	leal	216(%esp), %edx
	movl	%edx, 12(%esp)
	movl	%ebx, 16(%esp)
	movl	%esi, 20(%esp)
	movl	0(%edx), %ebx
	xorl	%edx, %edx
.L117:
	leal	48(%esp), %ecx
	movb	%dl, 0(%ecx,%edx,1)
	leal	1(%edx), %edx
	cmpl	$64, %edx
	jl	.L117
	leal	112(%esp), %eax
	movl	%eax, 0(%esp)
	call	SHA1_init
.L118:
	testl	%ebx, %ebx
	jle	.L119
	leal	112(%esp), %esi
	leal	48(%esp), %ecx
	movl	$64, %eax
	movl	%esi, 0(%esp)
	movl	%ecx, 4(%esp)
	movl	%eax, 8(%esp)
	call	SHA1_add_data
	leal	-1(%ebx), %ebx
	jmp	.L118
.L119:
	leal	112(%esp), %eax
	leal	24(%esp), %ecx
	movl	%eax, 0(%esp)
	movl	%ecx, 4(%esp)
	call	SHA1_finish
	movl	16(%esp), %ebx
	movl	20(%esp), %esi
	addl	$212, %esp
	ret
	.cfi_endproc
	.type	do_bench, @function
	.size	do_bench, . - do_bench
	.text
	.align	16
	.globl main
main:
	.cfi_startproc
	subl	$20, %esp
	.cfi_adjust_cfa_offset	20
	leal	24(%esp), %edx
	movl	%edx, 8(%esp)
	movl	$305419896, %eax
	movl	%eax, 16(%esp)
	movzbl	16(%esp), %eax
	cmpl	$18, %eax
	je	.L120
	cmpl	$120, %eax
	jne	.L121
	xorl	%eax, %eax
	movl	%eax, arch_big_endian
	jmp	.L122
.L121:
	leal	__stringlit_4, %ecx
	movl	%ecx, 0(%esp)
	call	printf
	movl	$2, %eax
	jmp	.L123
.L120:
	movl	$1, %eax
	movl	%eax, arch_big_endian
.L122:
	leal	test_input_1, %eax
	leal	test_output_1, %edx
	movl	%eax, 0(%esp)
	movl	%edx, 4(%esp)
	call	do_test
	leal	test_input_2, %edx
	leal	test_output_2, %eax
	movl	%edx, 0(%esp)
	movl	%eax, 4(%esp)
	call	do_test
	movl	$10000000, %eax
	movl	%eax, 0(%esp)
	call	do_bench
	xorl	%eax, %eax
.L123:
	addl	$20, %esp
	ret
	.cfi_endproc
	.type	main, @function
	.size	main, . - main
